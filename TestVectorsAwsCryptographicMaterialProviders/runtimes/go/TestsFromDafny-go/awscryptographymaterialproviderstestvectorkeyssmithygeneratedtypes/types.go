// Code generated by smithy-go-codegen DO NOT EDIT.

package awscryptographymaterialproviderstestvectorkeyssmithygeneratedtypes

import (
	"fmt"
	"unicode/utf8"

	"github.com/aws/aws-cryptographic-material-providers-library/mpl/awscryptographymaterialproviderssmithygeneratedtypes"
	kmstypes "github.com/aws/aws-sdk-go-v2/service/kms/types"
)

type RawAES struct {
	KeyId string

	ProviderId string
}

func (input RawAES) Validate() error {

	return nil
}

type RawEcdh struct {
	CurveSpec string

	KeyAgreementScheme string

	ProviderId string

	RecipientKeyId string

	RecipientPublicKey string

	SenderKeyId string

	SenderPublicKey string
}

func (input RawEcdh) Validate() error {

	return nil
}

type HierarchyKeyring struct {
	KeyId string
}

func (input HierarchyKeyring) Validate() error {

	return nil
}

type KMSInfo struct {
	KeyId string
}

func (input KMSInfo) Validate() error {

	return nil
}

type KmsEcdhKeyring struct {
	CurveSpec string

	KeyAgreementScheme string

	RecipientKeyId string

	RecipientPublicKey string

	SenderKeyId string

	SenderPublicKey string
}

func (input KmsEcdhKeyring) Validate() error {

	return nil
}

type KmsMrkAware struct {
	KeyId string
}

func (input KmsMrkAware) Validate() error {

	return nil
}

type KmsMrkAwareDiscovery struct {
	DefaultMrkRegion string

	KeyId string

	AwsKmsDiscoveryFilter *awscryptographymaterialproviderssmithygeneratedtypes.DiscoveryFilter
}

func (input KmsMrkAwareDiscovery) Validate() error {
	if input.AwsKmsDiscoveryFilter != nil {
		if input.AwsKmsDiscoveryFilter.Validate() != nil {
			return input.AwsKmsDiscoveryFilter.Validate()
		}

	}

	return nil
}

type KmsRsaKeyring struct {
	EncryptionAlgorithm kmstypes.EncryptionAlgorithmSpec

	KeyId string
}

func (input KmsRsaKeyring) Validate() error {

	return nil
}

type RawRSA struct {
	KeyId string

	Padding awscryptographymaterialproviderssmithygeneratedtypes.PaddingScheme

	ProviderId string
}

func (input RawRSA) Validate() error {

	return nil
}

type StaticKeyring struct {
	KeyId string
}

func (input StaticKeyring) Validate() error {

	return nil
}

type CreateWrappedTestVectorCmmOutput struct {
	Cmm awscryptographymaterialproviderssmithygeneratedtypes.ICryptographicMaterialsManager
}

func (input CreateWrappedTestVectorCmmOutput) Validate() error {

	return nil
}

type GetKeyDescriptionInput struct {
	Json []byte
}

func (input GetKeyDescriptionInput) Validate() error {

	return nil
}

type SerializeKeyDescriptionOutput struct {
	Json []byte
}

func (input SerializeKeyDescriptionOutput) Validate() error {

	return nil
}

type RequiredEncryptionContextCMM struct {
	RequiredEncryptionContextKeys []string

	Underlying KeyDescription
}

func (input RequiredEncryptionContextCMM) Validate() error {
	if input.RequiredEncryptionContextKeys == nil {
		return fmt.Errorf("input.RequiredEncryptionContextKeys is required but has a nil value.")
	}
	if input.aws_cryptography_materialProvidersTestVectorKeys_RequiredEncryptionContextCMM_requiredEncryptionContextKeys_Validate() != nil {
		return input.aws_cryptography_materialProvidersTestVectorKeys_RequiredEncryptionContextCMM_requiredEncryptionContextKeys_Validate()
	}
	if input.Underlying == nil {
		return fmt.Errorf("input.Underlying is required but has a nil value.")
	}
	if input.aws_cryptography_materialProvidersTestVectorKeys_RequiredEncryptionContextCMM_underlying_Validate() != nil {
		return input.aws_cryptography_materialProvidersTestVectorKeys_RequiredEncryptionContextCMM_underlying_Validate()
	}

	return nil
}

func (input RequiredEncryptionContextCMM) aws_cryptography_materialProvidersTestVectorKeys_RequiredEncryptionContextCMM_requiredEncryptionContextKeys_Validate() error {
	for _, item := range input.RequiredEncryptionContextKeys {
		if !utf8.ValidString(item) {
			return fmt.Errorf("Invalid UTF bytes %s ", item)
		}
	}

	return nil
}
func (input RequiredEncryptionContextCMM) aws_cryptography_materialProvidersTestVectorKeys_RequiredEncryptionContextCMM_underlying_Validate() error {
	if input.Underlying == nil {
		return nil
	}
	switch unionType := input.Underlying.(type) {
	case *KeyDescriptionMemberKms:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrk:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrkDiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRSA:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberAES:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberStatic:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsRsa:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberHierarchy:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberMulti:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRequiredEncryptionContext:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type GetKeyDescriptionOutput struct {
	KeyDescription KeyDescription
}

func (input GetKeyDescriptionOutput) Validate() error {
	if input.KeyDescription == nil {
		return fmt.Errorf("input.KeyDescription is required but has a nil value.")
	}
	if input.aws_cryptography_materialProvidersTestVectorKeys_GetKeyDescriptionOutput_keyDescription_Validate() != nil {
		return input.aws_cryptography_materialProvidersTestVectorKeys_GetKeyDescriptionOutput_keyDescription_Validate()
	}

	return nil
}

func (input GetKeyDescriptionOutput) aws_cryptography_materialProvidersTestVectorKeys_GetKeyDescriptionOutput_keyDescription_Validate() error {
	if input.KeyDescription == nil {
		return nil
	}
	switch unionType := input.KeyDescription.(type) {
	case *KeyDescriptionMemberKms:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrk:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrkDiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRSA:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberAES:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberStatic:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsRsa:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberHierarchy:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberMulti:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRequiredEncryptionContext:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type SerializeKeyDescriptionInput struct {
	KeyDescription KeyDescription
}

func (input SerializeKeyDescriptionInput) Validate() error {
	if input.KeyDescription == nil {
		return fmt.Errorf("input.KeyDescription is required but has a nil value.")
	}
	if input.aws_cryptography_materialProvidersTestVectorKeys_SerializeKeyDescriptionInput_keyDescription_Validate() != nil {
		return input.aws_cryptography_materialProvidersTestVectorKeys_SerializeKeyDescriptionInput_keyDescription_Validate()
	}

	return nil
}

func (input SerializeKeyDescriptionInput) aws_cryptography_materialProvidersTestVectorKeys_SerializeKeyDescriptionInput_keyDescription_Validate() error {
	if input.KeyDescription == nil {
		return nil
	}
	switch unionType := input.KeyDescription.(type) {
	case *KeyDescriptionMemberKms:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrk:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrkDiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRSA:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberAES:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberStatic:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsRsa:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberHierarchy:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberMulti:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRequiredEncryptionContext:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type TestVectorCmmInput struct {
	ForOperation CmmOperation

	KeyDescription KeyDescription
}

func (input TestVectorCmmInput) Validate() error {
	if input.KeyDescription == nil {
		return fmt.Errorf("input.KeyDescription is required but has a nil value.")
	}
	if input.aws_cryptography_materialProvidersTestVectorKeys_TestVectorCmmInput_keyDescription_Validate() != nil {
		return input.aws_cryptography_materialProvidersTestVectorKeys_TestVectorCmmInput_keyDescription_Validate()
	}

	return nil
}

func (input TestVectorCmmInput) aws_cryptography_materialProvidersTestVectorKeys_TestVectorCmmInput_keyDescription_Validate() error {
	if input.KeyDescription == nil {
		return nil
	}
	switch unionType := input.KeyDescription.(type) {
	case *KeyDescriptionMemberKms:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrk:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrkDiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRSA:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberAES:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberStatic:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsRsa:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberHierarchy:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberMulti:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRequiredEncryptionContext:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type TestVectorKeyringInput struct {
	KeyDescription KeyDescription
}

func (input TestVectorKeyringInput) Validate() error {
	if input.KeyDescription == nil {
		return fmt.Errorf("input.KeyDescription is required but has a nil value.")
	}
	if input.aws_cryptography_materialProvidersTestVectorKeys_TestVectorKeyringInput_keyDescription_Validate() != nil {
		return input.aws_cryptography_materialProvidersTestVectorKeys_TestVectorKeyringInput_keyDescription_Validate()
	}

	return nil
}

func (input TestVectorKeyringInput) aws_cryptography_materialProvidersTestVectorKeys_TestVectorKeyringInput_keyDescription_Validate() error {
	if input.KeyDescription == nil {
		return nil
	}
	switch unionType := input.KeyDescription.(type) {
	case *KeyDescriptionMemberKms:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrk:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrkDiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRSA:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberAES:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberStatic:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsRsa:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberHierarchy:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberMulti:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRequiredEncryptionContext:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type MultiKeyring struct {
	ChildKeyrings []KeyDescription

	Generator KeyDescription
}

func (input MultiKeyring) Validate() error {
	if input.ChildKeyrings == nil {
		return fmt.Errorf("input.ChildKeyrings is required but has a nil value.")
	}
	if input.aws_cryptography_materialProvidersTestVectorKeys_MultiKeyring_childKeyrings_Validate() != nil {
		return input.aws_cryptography_materialProvidersTestVectorKeys_MultiKeyring_childKeyrings_Validate()
	}
	if input.aws_cryptography_materialProvidersTestVectorKeys_MultiKeyring_generator_Validate() != nil {
		return input.aws_cryptography_materialProvidersTestVectorKeys_MultiKeyring_generator_Validate()
	}

	return nil
}

func (input MultiKeyring) aws_cryptography_materialProvidersTestVectorKeys_KeyDescriptionList_member_Validate(Value KeyDescription) error {
	if Value == nil {
		return nil
	}
	switch unionType := Value.(type) {
	case *KeyDescriptionMemberKms:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrk:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrkDiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRSA:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberAES:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberStatic:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsRsa:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberHierarchy:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberMulti:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRequiredEncryptionContext:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input MultiKeyring) aws_cryptography_materialProvidersTestVectorKeys_MultiKeyring_childKeyrings_Validate() error {
	for _, item := range input.ChildKeyrings {
		if input.aws_cryptography_materialProvidersTestVectorKeys_KeyDescriptionList_member_Validate(item) != nil {
			return input.aws_cryptography_materialProvidersTestVectorKeys_KeyDescriptionList_member_Validate(item)
		}
	}

	return nil
}
func (input MultiKeyring) aws_cryptography_materialProvidersTestVectorKeys_MultiKeyring_generator_Validate() error {
	if input.Generator == nil {
		return nil
	}
	switch unionType := input.Generator.(type) {
	case *KeyDescriptionMemberKms:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrk:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsMrkDiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRSA:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberAES:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberStatic:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsRsa:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberKmsECDH:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberHierarchy:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberMulti:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KeyDescriptionMemberRequiredEncryptionContext:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type KeyVectorsConfig struct {
	KeyManifestPath string
}

func (input KeyVectorsConfig) Validate() error {

	return nil
}

// KeyDescriptionMemberAES
// KeyDescriptionMemberECDH
// KeyDescriptionMemberHierarchy
// KeyDescriptionMemberKms
// KeyDescriptionMemberKmsECDH
// KeyDescriptionMemberKmsMrk
// KeyDescriptionMemberKmsMrkDiscovery
// KeyDescriptionMemberKmsRsa
// KeyDescriptionMemberMulti
// KeyDescriptionMemberRSA
// KeyDescriptionMemberRequiredEncryptionContext
// KeyDescriptionMemberStatic
type KeyDescription interface {
	isKeyDescription()
}

type KeyDescriptionMemberAES struct {
	Value RawAES
}

func (*KeyDescriptionMemberAES) isKeyDescription() {}

type KeyDescriptionMemberECDH struct {
	Value RawEcdh
}

func (*KeyDescriptionMemberECDH) isKeyDescription() {}

type KeyDescriptionMemberHierarchy struct {
	Value HierarchyKeyring
}

func (*KeyDescriptionMemberHierarchy) isKeyDescription() {}

type KeyDescriptionMemberKms struct {
	Value KMSInfo
}

func (*KeyDescriptionMemberKms) isKeyDescription() {}

type KeyDescriptionMemberKmsECDH struct {
	Value KmsEcdhKeyring
}

func (*KeyDescriptionMemberKmsECDH) isKeyDescription() {}

type KeyDescriptionMemberKmsMrk struct {
	Value KmsMrkAware
}

func (*KeyDescriptionMemberKmsMrk) isKeyDescription() {}

type KeyDescriptionMemberKmsMrkDiscovery struct {
	Value KmsMrkAwareDiscovery
}

func (*KeyDescriptionMemberKmsMrkDiscovery) isKeyDescription() {}

type KeyDescriptionMemberKmsRsa struct {
	Value KmsRsaKeyring
}

func (*KeyDescriptionMemberKmsRsa) isKeyDescription() {}

type KeyDescriptionMemberMulti struct {
	Value MultiKeyring
}

func (*KeyDescriptionMemberMulti) isKeyDescription() {}

type KeyDescriptionMemberRequiredEncryptionContext struct {
	Value RequiredEncryptionContextCMM
}

func (*KeyDescriptionMemberRequiredEncryptionContext) isKeyDescription() {}

type KeyDescriptionMemberRSA struct {
	Value RawRSA
}

func (*KeyDescriptionMemberRSA) isKeyDescription() {}

type KeyDescriptionMemberStatic struct {
	Value StaticKeyring
}

func (*KeyDescriptionMemberStatic) isKeyDescription() {}

type KeyVectorsBaseException interface {
	// This is a dummy method to allow type assertion since Go empty interfaces
	// aren't useful for type assertion checks. No concrete class is expected to implement
	// this method. This is also not exported.
	interfaceBindingMethod()
}
