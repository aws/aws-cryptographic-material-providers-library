// Code generated by smithy-go-codegen DO NOT EDIT.

package awscryptographykeystoresmithygenerated

import (
	"github.com/aws/aws-cryptographic-material-providers-library/dynamodb/DynamoDBwrapped"
	"github.com/aws/aws-cryptographic-material-providers-library/dynamodb/comamazonawsdynamodbsmithygenerated"
	"github.com/aws/aws-cryptographic-material-providers-library/kms/KMSwrapped"
	"github.com/aws/aws-cryptographic-material-providers-library/kms/comamazonawskmssmithygenerated"
	"github.com/aws/aws-cryptographic-material-providers-library/mpl/AwsCryptographyKeyStoreTypes"
	"github.com/aws/aws-cryptographic-material-providers-library/mpl/awscryptographykeystoresmithygeneratedtypes"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/kms"
	"github.com/dafny-lang/DafnyRuntimeGo/v4/dafny"
	"github.com/dafny-lang/DafnyStandardLibGo/Wrappers"
)

func GetKeyStoreInfoOutput_FromDafny(dafnyOutput AwsCryptographyKeyStoreTypes.GetKeyStoreInfoOutput) awscryptographykeystoresmithygeneratedtypes.GetKeyStoreInfoOutput {

	return awscryptographykeystoresmithygeneratedtypes.GetKeyStoreInfoOutput{KeyStoreId: aws_cryptography_keyStore_GetKeyStoreInfoOutput_keyStoreId_FromDafny(dafnyOutput.Dtor_keyStoreId()),
		KeyStoreName:        aws_cryptography_keyStore_GetKeyStoreInfoOutput_keyStoreName_FromDafny(dafnyOutput.Dtor_keyStoreName()),
		LogicalKeyStoreName: aws_cryptography_keyStore_GetKeyStoreInfoOutput_logicalKeyStoreName_FromDafny(dafnyOutput.Dtor_logicalKeyStoreName()),
		GrantTokens:         aws_cryptography_keyStore_GetKeyStoreInfoOutput_grantTokens_FromDafny(dafnyOutput.Dtor_grantTokens()),
		KmsConfiguration:    aws_cryptography_keyStore_GetKeyStoreInfoOutput_kmsConfiguration_FromDafny(dafnyOutput.Dtor_kmsConfiguration()),
	}

}

func CreateKeyStoreInput_FromDafny(dafnyInput AwsCryptographyKeyStoreTypes.CreateKeyStoreInput) awscryptographykeystoresmithygeneratedtypes.CreateKeyStoreInput {

	return awscryptographykeystoresmithygeneratedtypes.CreateKeyStoreInput{}

}

func CreateKeyStoreOutput_FromDafny(dafnyOutput AwsCryptographyKeyStoreTypes.CreateKeyStoreOutput) awscryptographykeystoresmithygeneratedtypes.CreateKeyStoreOutput {

	return awscryptographykeystoresmithygeneratedtypes.CreateKeyStoreOutput{TableArn: aws_cryptography_keyStore_CreateKeyStoreOutput_tableArn_FromDafny(dafnyOutput.Dtor_tableArn())}

}

func CreateKeyInput_FromDafny(dafnyInput AwsCryptographyKeyStoreTypes.CreateKeyInput) awscryptographykeystoresmithygeneratedtypes.CreateKeyInput {

	return awscryptographykeystoresmithygeneratedtypes.CreateKeyInput{BranchKeyIdentifier: aws_cryptography_keyStore_CreateKeyInput_branchKeyIdentifier_FromDafny(dafnyInput.Dtor_branchKeyIdentifier().UnwrapOr(nil)),
		EncryptionContext: aws_cryptography_keyStore_CreateKeyInput_encryptionContext_FromDafny(dafnyInput.Dtor_encryptionContext().UnwrapOr(nil)),
	}

}

func CreateKeyOutput_FromDafny(dafnyOutput AwsCryptographyKeyStoreTypes.CreateKeyOutput) awscryptographykeystoresmithygeneratedtypes.CreateKeyOutput {

	return awscryptographykeystoresmithygeneratedtypes.CreateKeyOutput{BranchKeyIdentifier: aws_cryptography_keyStore_CreateKeyOutput_branchKeyIdentifier_FromDafny(dafnyOutput.Dtor_branchKeyIdentifier())}

}

func VersionKeyInput_FromDafny(dafnyInput AwsCryptographyKeyStoreTypes.VersionKeyInput) awscryptographykeystoresmithygeneratedtypes.VersionKeyInput {

	return awscryptographykeystoresmithygeneratedtypes.VersionKeyInput{BranchKeyIdentifier: aws_cryptography_keyStore_VersionKeyInput_branchKeyIdentifier_FromDafny(dafnyInput.Dtor_branchKeyIdentifier())}

}

func VersionKeyOutput_FromDafny(dafnyOutput AwsCryptographyKeyStoreTypes.VersionKeyOutput) awscryptographykeystoresmithygeneratedtypes.VersionKeyOutput {

	return awscryptographykeystoresmithygeneratedtypes.VersionKeyOutput{}

}

func GetActiveBranchKeyInput_FromDafny(dafnyInput AwsCryptographyKeyStoreTypes.GetActiveBranchKeyInput) awscryptographykeystoresmithygeneratedtypes.GetActiveBranchKeyInput {

	return awscryptographykeystoresmithygeneratedtypes.GetActiveBranchKeyInput{BranchKeyIdentifier: aws_cryptography_keyStore_GetActiveBranchKeyInput_branchKeyIdentifier_FromDafny(dafnyInput.Dtor_branchKeyIdentifier())}

}

func GetActiveBranchKeyOutput_FromDafny(dafnyOutput AwsCryptographyKeyStoreTypes.GetActiveBranchKeyOutput) awscryptographykeystoresmithygeneratedtypes.GetActiveBranchKeyOutput {

	return awscryptographykeystoresmithygeneratedtypes.GetActiveBranchKeyOutput{BranchKeyMaterials: aws_cryptography_keyStore_GetActiveBranchKeyOutput_branchKeyMaterials_FromDafny(dafnyOutput.Dtor_branchKeyMaterials())}

}

func GetBranchKeyVersionInput_FromDafny(dafnyInput AwsCryptographyKeyStoreTypes.GetBranchKeyVersionInput) awscryptographykeystoresmithygeneratedtypes.GetBranchKeyVersionInput {

	return awscryptographykeystoresmithygeneratedtypes.GetBranchKeyVersionInput{BranchKeyIdentifier: aws_cryptography_keyStore_GetBranchKeyVersionInput_branchKeyIdentifier_FromDafny(dafnyInput.Dtor_branchKeyIdentifier()),
		BranchKeyVersion: aws_cryptography_keyStore_GetBranchKeyVersionInput_branchKeyVersion_FromDafny(dafnyInput.Dtor_branchKeyVersion()),
	}

}

func GetBranchKeyVersionOutput_FromDafny(dafnyOutput AwsCryptographyKeyStoreTypes.GetBranchKeyVersionOutput) awscryptographykeystoresmithygeneratedtypes.GetBranchKeyVersionOutput {

	return awscryptographykeystoresmithygeneratedtypes.GetBranchKeyVersionOutput{BranchKeyMaterials: aws_cryptography_keyStore_GetBranchKeyVersionOutput_branchKeyMaterials_FromDafny(dafnyOutput.Dtor_branchKeyMaterials())}

}

func GetBeaconKeyInput_FromDafny(dafnyInput AwsCryptographyKeyStoreTypes.GetBeaconKeyInput) awscryptographykeystoresmithygeneratedtypes.GetBeaconKeyInput {

	return awscryptographykeystoresmithygeneratedtypes.GetBeaconKeyInput{BranchKeyIdentifier: aws_cryptography_keyStore_GetBeaconKeyInput_branchKeyIdentifier_FromDafny(dafnyInput.Dtor_branchKeyIdentifier())}

}

func GetBeaconKeyOutput_FromDafny(dafnyOutput AwsCryptographyKeyStoreTypes.GetBeaconKeyOutput) awscryptographykeystoresmithygeneratedtypes.GetBeaconKeyOutput {

	return awscryptographykeystoresmithygeneratedtypes.GetBeaconKeyOutput{BeaconKeyMaterials: aws_cryptography_keyStore_GetBeaconKeyOutput_beaconKeyMaterials_FromDafny(dafnyOutput.Dtor_beaconKeyMaterials())}

}

func KeyStoreException_FromDafny(dafnyOutput AwsCryptographyKeyStoreTypes.Error) awscryptographykeystoresmithygeneratedtypes.KeyStoreException {
	return awscryptographykeystoresmithygeneratedtypes.KeyStoreException{Message: aws_cryptography_keyStore_KeyStoreException_message_FromDafny(dafnyOutput.Dtor_message())}

}

func CollectionOfErrors_Output_FromDafny(dafnyOutput AwsCryptographyKeyStoreTypes.Error) awscryptographykeystoresmithygeneratedtypes.CollectionOfErrors {
	listOfErrors := dafnyOutput.Dtor_list()
	message := dafnyOutput.Dtor_message()
	t := awscryptographykeystoresmithygeneratedtypes.CollectionOfErrors{}
	for i := dafny.Iterate(listOfErrors); ; {
		val, ok := i()
		if !ok {
			break
		}
		err := val.(AwsCryptographyKeyStoreTypes.Error)
		t.ListOfErrors = append(t.ListOfErrors, Error_FromDafny(err))

	}
	t.Message = func() string {
		var s string
		for i := dafny.Iterate(message); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
	return t
}
func OpaqueError_Output_FromDafny(dafnyOutput AwsCryptographyKeyStoreTypes.Error) awscryptographykeystoresmithygeneratedtypes.OpaqueError {
	return awscryptographykeystoresmithygeneratedtypes.OpaqueError{
		ErrObject: dafnyOutput.Dtor_obj(),
	}
}

func Error_FromDafny(err AwsCryptographyKeyStoreTypes.Error) error {
	// Service Errors
	if err.Is_KeyStoreException() {
		return KeyStoreException_FromDafny(err)
	}

	//DependentErrors
	if err.Is_ComAmazonawsDynamodb() {
		return comamazonawsdynamodbsmithygenerated.Error_FromDafny(err.Dtor_ComAmazonawsDynamodb())
	}

	if err.Is_ComAmazonawsKms() {
		return comamazonawskmssmithygenerated.Error_FromDafny(err.Dtor_ComAmazonawsKms())
	}

	//Unmodelled Errors
	if err.Is_CollectionOfErrors() {
		return CollectionOfErrors_Output_FromDafny(err)
	}

	return OpaqueError_Output_FromDafny(err)
}

func KeyStoreConfig_FromDafny(dafnyOutput AwsCryptographyKeyStoreTypes.KeyStoreConfig) awscryptographykeystoresmithygeneratedtypes.KeyStoreConfig {
	return awscryptographykeystoresmithygeneratedtypes.KeyStoreConfig{DdbTableName: aws_cryptography_keyStore_KeyStoreConfig_ddbTableName_FromDafny(dafnyOutput.Dtor_ddbTableName()),
		KmsConfiguration:    aws_cryptography_keyStore_KeyStoreConfig_kmsConfiguration_FromDafny(dafnyOutput.Dtor_kmsConfiguration()),
		LogicalKeyStoreName: aws_cryptography_keyStore_KeyStoreConfig_logicalKeyStoreName_FromDafny(dafnyOutput.Dtor_logicalKeyStoreName()),
		Id:                  aws_cryptography_keyStore_KeyStoreConfig_id_FromDafny(dafnyOutput.Dtor_id().UnwrapOr(nil)),
		GrantTokens:         aws_cryptography_keyStore_KeyStoreConfig_grantTokens_FromDafny(dafnyOutput.Dtor_grantTokens().UnwrapOr(nil)),
		DdbClient:           aws_cryptography_keyStore_KeyStoreConfig_ddbClient_FromDafny(dafnyOutput.Dtor_ddbClient().UnwrapOr(nil)),
		KmsClient:           aws_cryptography_keyStore_KeyStoreConfig_kmsClient_FromDafny(dafnyOutput.Dtor_kmsClient().UnwrapOr(nil)),
	}

}

func aws_cryptography_keyStore_GetKeyStoreInfoOutput_kmsConfiguration_FromDafny(input interface{}) awscryptographykeystoresmithygeneratedtypes.KMSConfiguration {
	var union awscryptographykeystoresmithygeneratedtypes.KMSConfiguration

	if (input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Is_kmsKeyArn() {
		var dataSource = Wrappers.Companion_Option_.Create_Some_((input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Dtor_kmsKeyArn())
		union = &awscryptographykeystoresmithygeneratedtypes.KMSConfigurationMemberkmsKeyArn{
			Value: (aws_cryptography_keyStore_KMSConfiguration_kmsKeyArn_FromDafny(dataSource.UnwrapOr(nil))),
		}
	}
	if (input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Is_kmsMRKeyArn() {
		var dataSource = Wrappers.Companion_Option_.Create_Some_((input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Dtor_kmsMRKeyArn())
		union = &awscryptographykeystoresmithygeneratedtypes.KMSConfigurationMemberkmsMRKeyArn{
			Value: (aws_cryptography_keyStore_KMSConfiguration_kmsMRKeyArn_FromDafny(dataSource.UnwrapOr(nil))),
		}
	}
	if (input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Is_discovery() {

		union = &awscryptographykeystoresmithygeneratedtypes.KMSConfigurationMemberdiscovery{
			Value: (aws_cryptography_keyStore_KMSConfiguration_discovery_FromDafny((input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Dtor_discovery())),
		}
	}
	if (input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Is_mrDiscovery() {

		union = &awscryptographykeystoresmithygeneratedtypes.KMSConfigurationMembermrDiscovery{
			Value: (aws_cryptography_keyStore_KMSConfiguration_mrDiscovery_FromDafny((input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Dtor_mrDiscovery())),
		}
	}

	return union

}
func aws_cryptography_keyStore_KeyStoreException_message_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_KeyStoreConfig_id_FromDafny(input interface{}) *string {
	return func() *string {
		var s string
		if input == nil {
			return nil
		}
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return &[]string{s}[0]
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_KeyStoreConfig_kmsClient_FromDafny(input interface{}) *kms.Client {
	shim, ok := input.(*KMSwrapped.Shim)
	if !ok {
		panic("Not able to convert client to native")
	}
	return shim.Client

}
func aws_cryptography_keyStore_GetBranchKeyVersionInput_branchKeyIdentifier_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_GetBranchKeyVersionInput_branchKeyVersion_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_KMSConfiguration_discovery_FromDafny(input interface{}) awscryptographykeystoresmithygeneratedtypes.Discovery {
	return awscryptographykeystoresmithygeneratedtypes.Discovery{}
}
func aws_cryptography_keyStore_CreateKeyInput_encryptionContext_FromDafny(input interface{}) map[string]string {
	var m map[string]string = make(map[string]string)
	if input == nil {
		return nil
	}
	for i := dafny.Iterate(input.(dafny.Map).Items()); ; {
		val, ok := i()
		if !ok {
			break
		}
		m[aws_cryptography_keyStore_EncryptionContext_key_FromDafny((*val.(dafny.Tuple).IndexInt(0)))] = aws_cryptography_keyStore_EncryptionContext_value_FromDafny((*val.(dafny.Tuple).IndexInt(1)))
	}
	return m

}
func aws_cryptography_keyStore_CreateKeyInput_branchKeyIdentifier_FromDafny(input interface{}) *string {
	return func() *string {
		var s string
		if input == nil {
			return nil
		}
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return &[]string{s}[0]
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_EncryptionContext_key_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				// UTF bytes should be always converted from bytes to string in go
				// Otherwise go treats the string as a unicode codepoint

				var valUint, _ = val.(uint8)
				var byteSlice = []byte{valUint}
				s = s + string(byteSlice)

			}
		}
	}()
}
func aws_cryptography_keyStore_GetBeaconKeyInput_branchKeyIdentifier_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_CreateKeyStoreOutput_tableArn_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_GetActiveBranchKeyInput_branchKeyIdentifier_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_BranchKeyMaterials_encryptionContext_FromDafny(input interface{}) map[string]string {
	var m map[string]string = make(map[string]string)
	if input == nil {
		return nil
	}
	for i := dafny.Iterate(input.(dafny.Map).Items()); ; {
		val, ok := i()
		if !ok {
			break
		}
		m[aws_cryptography_keyStore_EncryptionContext_key_FromDafny((*val.(dafny.Tuple).IndexInt(0)))] = aws_cryptography_keyStore_EncryptionContext_value_FromDafny((*val.(dafny.Tuple).IndexInt(1)))
	}
	return m

}
func aws_cryptography_keyStore_MRDiscovery_region_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_GetActiveBranchKeyOutput_branchKeyMaterials_FromDafny(input interface{}) awscryptographykeystoresmithygeneratedtypes.BranchKeyMaterials {
	return awscryptographykeystoresmithygeneratedtypes.BranchKeyMaterials{BranchKeyIdentifier: aws_cryptography_keyStore_BranchKeyMaterials_branchKeyIdentifier_FromDafny(input.(AwsCryptographyKeyStoreTypes.BranchKeyMaterials).Dtor_branchKeyIdentifier()),
		BranchKeyVersion:  aws_cryptography_keyStore_BranchKeyMaterials_branchKeyVersion_FromDafny(input.(AwsCryptographyKeyStoreTypes.BranchKeyMaterials).Dtor_branchKeyVersion()),
		EncryptionContext: aws_cryptography_keyStore_BranchKeyMaterials_encryptionContext_FromDafny(input.(AwsCryptographyKeyStoreTypes.BranchKeyMaterials).Dtor_encryptionContext()),
		BranchKey:         aws_cryptography_keyStore_BranchKeyMaterials_branchKey_FromDafny(input.(AwsCryptographyKeyStoreTypes.BranchKeyMaterials).Dtor_branchKey()),
	}
}
func aws_cryptography_keyStore_KeyStoreConfig_ddbClient_FromDafny(input interface{}) *dynamodb.Client {
	shim, ok := input.(*DynamoDBwrapped.Shim)
	if !ok {
		panic("Not able to convert client to native")
	}
	return shim.Client

}
func aws_cryptography_keyStore_GetKeyStoreInfoOutput_grantTokens_FromDafny(input interface{}) []string {
	fieldValue := make([]string, 0)
	for i := dafny.Iterate(input.(dafny.Sequence)); ; {
		val, ok := i()
		if !ok {
			break
		}
		fieldValue = append(fieldValue, aws_cryptography_keyStore_GrantTokenList_member_FromDafny(val))
	}
	return fieldValue
}
func aws_cryptography_keyStore_BeaconKeyMaterials_beaconKey_FromDafny(input interface{}) []byte {
	return func() []byte {
		var b []byte
		if input == nil {
			return nil
		}
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return b
			} else {
				b = append(b, val.(byte))
			}
		}
	}()
}
func aws_cryptography_keyStore_KMSConfiguration_kmsMRKeyArn_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_BeaconKeyMaterials_encryptionContext_FromDafny(input interface{}) map[string]string {
	var m map[string]string = make(map[string]string)
	if input == nil {
		return nil
	}
	for i := dafny.Iterate(input.(dafny.Map).Items()); ; {
		val, ok := i()
		if !ok {
			break
		}
		m[aws_cryptography_keyStore_EncryptionContext_key_FromDafny((*val.(dafny.Tuple).IndexInt(0)))] = aws_cryptography_keyStore_EncryptionContext_value_FromDafny((*val.(dafny.Tuple).IndexInt(1)))
	}
	return m

}
func aws_cryptography_keyStore_KeyStoreConfig_logicalKeyStoreName_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_BranchKeyMaterials_branchKey_FromDafny(input interface{}) []byte {
	return func() []byte {
		var b []byte
		if input == nil {
			return nil
		}
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return b
			} else {
				b = append(b, val.(byte))
			}
		}
	}()
}
func aws_cryptography_keyStore_KeyStoreConfig_ddbTableName_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_GrantTokenList_member_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_BranchKeyMaterials_branchKeyIdentifier_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_BeaconKeyMaterials_beaconKeyIdentifier_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_HmacKeyMap_key_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_GetKeyStoreInfoOutput_keyStoreName_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_GetKeyStoreInfoOutput_keyStoreId_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_EncryptionContext_value_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				// UTF bytes should be always converted from bytes to string in go
				// Otherwise go treats the string as a unicode codepoint

				var valUint, _ = val.(uint8)
				var byteSlice = []byte{valUint}
				s = s + string(byteSlice)

			}
		}
	}()
}
func aws_cryptography_keyStore_KMSConfiguration_kmsKeyArn_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_KMSConfiguration_mrDiscovery_FromDafny(input interface{}) awscryptographykeystoresmithygeneratedtypes.MRDiscovery {
	return awscryptographykeystoresmithygeneratedtypes.MRDiscovery{Region: aws_cryptography_keyStore_MRDiscovery_region_FromDafny(input.(AwsCryptographyKeyStoreTypes.MRDiscovery).Dtor_region())}
}
func aws_cryptography_keyStore_BranchKeyMaterials_branchKeyVersion_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				// UTF bytes should be always converted from bytes to string in go
				// Otherwise go treats the string as a unicode codepoint

				var valUint, _ = val.(uint8)
				var byteSlice = []byte{valUint}
				s = s + string(byteSlice)

			}
		}
	}()
}
func aws_cryptography_keyStore_GetBeaconKeyOutput_beaconKeyMaterials_FromDafny(input interface{}) awscryptographykeystoresmithygeneratedtypes.BeaconKeyMaterials {
	return awscryptographykeystoresmithygeneratedtypes.BeaconKeyMaterials{BeaconKeyIdentifier: aws_cryptography_keyStore_BeaconKeyMaterials_beaconKeyIdentifier_FromDafny(input.(AwsCryptographyKeyStoreTypes.BeaconKeyMaterials).Dtor_beaconKeyIdentifier()),
		EncryptionContext: aws_cryptography_keyStore_BeaconKeyMaterials_encryptionContext_FromDafny(input.(AwsCryptographyKeyStoreTypes.BeaconKeyMaterials).Dtor_encryptionContext()),
		BeaconKey:         aws_cryptography_keyStore_BeaconKeyMaterials_beaconKey_FromDafny(input.(AwsCryptographyKeyStoreTypes.BeaconKeyMaterials).Dtor_beaconKey().UnwrapOr(nil)),
		HmacKeys:          aws_cryptography_keyStore_BeaconKeyMaterials_hmacKeys_FromDafny(input.(AwsCryptographyKeyStoreTypes.BeaconKeyMaterials).Dtor_hmacKeys().UnwrapOr(nil)),
	}
}
func aws_cryptography_keyStore_GetKeyStoreInfoOutput_logicalKeyStoreName_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_KeyStoreConfig_kmsConfiguration_FromDafny(input interface{}) awscryptographykeystoresmithygeneratedtypes.KMSConfiguration {
	var union awscryptographykeystoresmithygeneratedtypes.KMSConfiguration

	if (input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Is_kmsKeyArn() {
		var dataSource = Wrappers.Companion_Option_.Create_Some_((input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Dtor_kmsKeyArn())
		union = &awscryptographykeystoresmithygeneratedtypes.KMSConfigurationMemberkmsKeyArn{
			Value: (aws_cryptography_keyStore_KMSConfiguration_kmsKeyArn_FromDafny(dataSource.UnwrapOr(nil))),
		}
	}
	if (input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Is_kmsMRKeyArn() {
		var dataSource = Wrappers.Companion_Option_.Create_Some_((input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Dtor_kmsMRKeyArn())
		union = &awscryptographykeystoresmithygeneratedtypes.KMSConfigurationMemberkmsMRKeyArn{
			Value: (aws_cryptography_keyStore_KMSConfiguration_kmsMRKeyArn_FromDafny(dataSource.UnwrapOr(nil))),
		}
	}
	if (input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Is_discovery() {

		union = &awscryptographykeystoresmithygeneratedtypes.KMSConfigurationMemberdiscovery{
			Value: (aws_cryptography_keyStore_KMSConfiguration_discovery_FromDafny((input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Dtor_discovery())),
		}
	}
	if (input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Is_mrDiscovery() {

		union = &awscryptographykeystoresmithygeneratedtypes.KMSConfigurationMembermrDiscovery{
			Value: (aws_cryptography_keyStore_KMSConfiguration_mrDiscovery_FromDafny((input.(AwsCryptographyKeyStoreTypes.KMSConfiguration)).Dtor_mrDiscovery())),
		}
	}

	return union

}
func aws_cryptography_keyStore_HmacKeyMap_value_FromDafny(input interface{}) []byte {
	return func() []byte {
		var b []byte
		if input == nil {
			return nil
		}
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return b
			} else {
				b = append(b, val.(byte))
			}
		}
	}()
}
func aws_cryptography_keyStore_VersionKeyInput_branchKeyIdentifier_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_BeaconKeyMaterials_hmacKeys_FromDafny(input interface{}) map[string][]byte {
	var m map[string][]byte = make(map[string][]byte)
	if input == nil {
		return nil
	}
	for i := dafny.Iterate(input.(dafny.Map).Items()); ; {
		val, ok := i()
		if !ok {
			break
		}
		m[aws_cryptography_keyStore_HmacKeyMap_key_FromDafny((*val.(dafny.Tuple).IndexInt(0)))] = aws_cryptography_keyStore_HmacKeyMap_value_FromDafny((*val.(dafny.Tuple).IndexInt(1)))
	}
	return m

}
func aws_cryptography_keyStore_CreateKeyOutput_branchKeyIdentifier_FromDafny(input interface{}) string {
	return func() string {
		var s string
		for i := dafny.Iterate(input); ; {
			val, ok := i()
			if !ok {
				return s
			} else {
				s = s + string(val.(dafny.Char))
			}
		}
	}()
}
func aws_cryptography_keyStore_KeyStoreConfig_grantTokens_FromDafny(input interface{}) []string {
	if input == nil {
		return nil
	}
	fieldValue := make([]string, 0)
	for i := dafny.Iterate(input.(dafny.Sequence)); ; {
		val, ok := i()
		if !ok {
			break
		}
		fieldValue = append(fieldValue, aws_cryptography_keyStore_GrantTokenList_member_FromDafny(val))
	}
	return fieldValue
}
func aws_cryptography_keyStore_GetBranchKeyVersionOutput_branchKeyMaterials_FromDafny(input interface{}) awscryptographykeystoresmithygeneratedtypes.BranchKeyMaterials {
	return awscryptographykeystoresmithygeneratedtypes.BranchKeyMaterials{BranchKeyIdentifier: aws_cryptography_keyStore_BranchKeyMaterials_branchKeyIdentifier_FromDafny(input.(AwsCryptographyKeyStoreTypes.BranchKeyMaterials).Dtor_branchKeyIdentifier()),
		BranchKeyVersion:  aws_cryptography_keyStore_BranchKeyMaterials_branchKeyVersion_FromDafny(input.(AwsCryptographyKeyStoreTypes.BranchKeyMaterials).Dtor_branchKeyVersion()),
		EncryptionContext: aws_cryptography_keyStore_BranchKeyMaterials_encryptionContext_FromDafny(input.(AwsCryptographyKeyStoreTypes.BranchKeyMaterials).Dtor_encryptionContext()),
		BranchKey:         aws_cryptography_keyStore_BranchKeyMaterials_branchKey_FromDafny(input.(AwsCryptographyKeyStoreTypes.BranchKeyMaterials).Dtor_branchKey()),
	}
}
