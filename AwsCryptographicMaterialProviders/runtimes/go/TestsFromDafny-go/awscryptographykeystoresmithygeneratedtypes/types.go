// Code generated by smithy-go-codegen DO NOT EDIT.

package awscryptographykeystoresmithygeneratedtypes

import (
	"fmt"
	"unicode/utf8"

	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/kms"
)

type BeaconKeyMaterials struct {
	BeaconKeyIdentifier string

	EncryptionContext map[string]string

	BeaconKey []byte

	HmacKeys map[string][]byte
}

func (input BeaconKeyMaterials) Validate() error {
	if input.EncryptionContext == nil {
		return fmt.Errorf("input.EncryptionContext is required but has a nil value.")
	}
	if input.aws_cryptography_keyStore_BeaconKeyMaterials_encryptionContext_Validate() != nil {
		return input.aws_cryptography_keyStore_BeaconKeyMaterials_encryptionContext_Validate()
	}

	return nil
}

func (input BeaconKeyMaterials) aws_cryptography_keyStore_BeaconKeyMaterials_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}

type BranchKeyMaterials struct {
	BranchKey []byte

	BranchKeyIdentifier string

	BranchKeyVersion string

	EncryptionContext map[string]string
}

func (input BranchKeyMaterials) Validate() error {
	if !utf8.ValidString(input.BranchKeyVersion) {
		return fmt.Errorf("Invalid UTF bytes %s ", input.BranchKeyVersion)
	}
	if input.EncryptionContext == nil {
		return fmt.Errorf("input.EncryptionContext is required but has a nil value.")
	}
	if input.aws_cryptography_keyStore_BranchKeyMaterials_encryptionContext_Validate() != nil {
		return input.aws_cryptography_keyStore_BranchKeyMaterials_encryptionContext_Validate()
	}

	return nil
}

func (input BranchKeyMaterials) aws_cryptography_keyStore_BranchKeyMaterials_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}

type CreateKeyInput struct {
	BranchKeyIdentifier *string

	EncryptionContext map[string]string
}

func (input CreateKeyInput) Validate() error {
	if input.aws_cryptography_keyStore_CreateKeyInput_encryptionContext_Validate() != nil {
		return input.aws_cryptography_keyStore_CreateKeyInput_encryptionContext_Validate()
	}

	return nil
}

func (input CreateKeyInput) aws_cryptography_keyStore_CreateKeyInput_encryptionContext_Validate() error {
	for key, value := range input.EncryptionContext {
		if !utf8.ValidString(key) {
			return fmt.Errorf("Invalid UTF bytes %s ", key)
		}
		if !utf8.ValidString(value) {
			return fmt.Errorf("Invalid UTF bytes %s ", value)
		}
	}

	return nil
}

type CreateKeyOutput struct {
	BranchKeyIdentifier string
}

func (input CreateKeyOutput) Validate() error {

	return nil
}

type CreateKeyStoreInput struct {
}

func (input CreateKeyStoreInput) Validate() error {

	return nil
}

type CreateKeyStoreOutput struct {
	TableArn string
}

func (input CreateKeyStoreOutput) Validate() error {
	if len(input.TableArn) < 1 {
		return fmt.Errorf("TableArn has a minimum length of 1 but has the length of %d.", len(input.TableArn))
	}
	if len(input.TableArn) > 1024 {
		return fmt.Errorf("TableArn has a maximum length of 1024 but has the length of %d.", len(input.TableArn))
	}

	return nil
}

type Discovery struct {
}

func (input Discovery) Validate() error {

	return nil
}

type GetActiveBranchKeyInput struct {
	BranchKeyIdentifier string
}

func (input GetActiveBranchKeyInput) Validate() error {

	return nil
}

type GetActiveBranchKeyOutput struct {
	BranchKeyMaterials BranchKeyMaterials
}

func (input GetActiveBranchKeyOutput) Validate() error {
	if input.BranchKeyMaterials.Validate() != nil {
		return input.BranchKeyMaterials.Validate()
	}

	return nil
}

type GetBeaconKeyInput struct {
	BranchKeyIdentifier string
}

func (input GetBeaconKeyInput) Validate() error {

	return nil
}

type GetBeaconKeyOutput struct {
	BeaconKeyMaterials BeaconKeyMaterials
}

func (input GetBeaconKeyOutput) Validate() error {
	if input.BeaconKeyMaterials.Validate() != nil {
		return input.BeaconKeyMaterials.Validate()
	}

	return nil
}

type GetBranchKeyVersionInput struct {
	BranchKeyIdentifier string

	BranchKeyVersion string
}

func (input GetBranchKeyVersionInput) Validate() error {

	return nil
}

type GetBranchKeyVersionOutput struct {
	BranchKeyMaterials BranchKeyMaterials
}

func (input GetBranchKeyVersionOutput) Validate() error {
	if input.BranchKeyMaterials.Validate() != nil {
		return input.BranchKeyMaterials.Validate()
	}

	return nil
}

type MRDiscovery struct {
	Region string
}

func (input MRDiscovery) Validate() error {
	if len(input.Region) < 1 {
		return fmt.Errorf("RegionType has a minimum length of 1 but has the length of %d.", len(input.Region))
	}
	if len(input.Region) > 32 {
		return fmt.Errorf("RegionType has a maximum length of 32 but has the length of %d.", len(input.Region))
	}

	return nil
}

type GetKeyStoreInfoOutput struct {
	GrantTokens []string

	KeyStoreId string

	KeyStoreName string

	KmsConfiguration KMSConfiguration

	LogicalKeyStoreName string
}

func (input GetKeyStoreInfoOutput) Validate() error {
	if input.GrantTokens == nil {
		return fmt.Errorf("input.GrantTokens is required but has a nil value.")
	}
	if input.KmsConfiguration == nil {
		return fmt.Errorf("input.KmsConfiguration is required but has a nil value.")
	}
	if input.aws_cryptography_keyStore_GetKeyStoreInfoOutput_kmsConfiguration_Validate() != nil {
		return input.aws_cryptography_keyStore_GetKeyStoreInfoOutput_kmsConfiguration_Validate()
	}

	return nil
}

func (input GetKeyStoreInfoOutput) aws_cryptography_keyStore_GetKeyStoreInfoOutput_kmsConfiguration_Validate() error {
	if input.KmsConfiguration == nil {
		return nil
	}
	switch unionType := input.KmsConfiguration.(type) {
	case *KMSConfigurationMemberkmsKeyArn:
		if len(unionType.Value) < 1 {
			return fmt.Errorf("KeyIdType has a minimum length of 1 but has the length of %d.", len(unionType.Value))
		}
		if len(unionType.Value) > 2048 {
			return fmt.Errorf("KeyIdType has a maximum length of 2048 but has the length of %d.", len(unionType.Value))
		}
	case *KMSConfigurationMemberkmsMRKeyArn:
		if len(unionType.Value) < 1 {
			return fmt.Errorf("KeyIdType has a minimum length of 1 but has the length of %d.", len(unionType.Value))
		}
		if len(unionType.Value) > 2048 {
			return fmt.Errorf("KeyIdType has a maximum length of 2048 but has the length of %d.", len(unionType.Value))
		}
	case *KMSConfigurationMemberdiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KMSConfigurationMembermrDiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type VersionKeyInput struct {
	BranchKeyIdentifier string
}

func (input VersionKeyInput) Validate() error {

	return nil
}

type VersionKeyOutput struct {
}

func (input VersionKeyOutput) Validate() error {

	return nil
}

type ActiveHierarchicalSymmetric struct {
	Version string
}

func (input ActiveHierarchicalSymmetric) Validate() error {

	return nil
}

type ActiveHierarchicalSymmetricBeacon struct {
}

func (input ActiveHierarchicalSymmetricBeacon) Validate() error {

	return nil
}

type KmsClientReference struct {
}

func (input KmsClientReference) Validate() error {

	return nil
}

type AwsKms struct {
	GrantTokens []string

	KmsClient *kms.Client
}

func (input AwsKms) Validate() error {

	return nil
}

type DdbClientReference struct {
}

func (input DdbClientReference) Validate() error {

	return nil
}

type DynamoDBTable struct {
	DdbTableName string

	DdbClient *dynamodb.Client
}

func (input DynamoDBTable) Validate() error {
	if len(input.DdbTableName) < 3 {
		return fmt.Errorf("TableName has a minimum length of 3 but has the length of %d.", len(input.DdbTableName))
	}
	if len(input.DdbTableName) > 255 {
		return fmt.Errorf("TableName has a maximum length of 255 but has the length of %d.", len(input.DdbTableName))
	}

	return nil
}

type HierarchicalSymmetric struct {
	Version string
}

func (input HierarchicalSymmetric) Validate() error {

	return nil
}

type EncryptedHierarchicalKey struct {
	CiphertextBlob []byte

	CreateTime string

	EncryptionContext map[string]string

	Identifier string

	KmsArn string

	Type HierarchicalKeyType
}

func (input EncryptedHierarchicalKey) Validate() error {
	if input.EncryptionContext == nil {
		return fmt.Errorf("input.EncryptionContext is required but has a nil value.")
	}
	if input.Type == nil {
		return fmt.Errorf("input.Type is required but has a nil value.")
	}
	if input.aws_cryptography_keyStore_EncryptedHierarchicalKey_Type_Validate() != nil {
		return input.aws_cryptography_keyStore_EncryptedHierarchicalKey_Type_Validate()
	}

	return nil
}

func (input EncryptedHierarchicalKey) aws_cryptography_keyStore_EncryptedHierarchicalKey_Type_Validate() error {
	if input.Type == nil {
		return nil
	}
	switch unionType := input.Type.(type) {
	case *HierarchicalKeyTypeMemberActiveHierarchicalSymmetricVersion:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *HierarchicalKeyTypeMemberHierarchicalSymmetricVersion:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *HierarchicalKeyTypeMemberActiveHierarchicalSymmetricBeacon:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

type GetEncryptedActiveBranchKeyInput struct {
	Identifier string
}

func (input GetEncryptedActiveBranchKeyInput) Validate() error {

	return nil
}

type GetEncryptedActiveBranchKeyOutput struct {
	Item EncryptedHierarchicalKey
}

func (input GetEncryptedActiveBranchKeyOutput) Validate() error {
	if input.Item.Validate() != nil {
		return input.Item.Validate()
	}

	return nil
}

type GetEncryptedBeaconKeyInput struct {
	Identifier string
}

func (input GetEncryptedBeaconKeyInput) Validate() error {

	return nil
}

type GetEncryptedBeaconKeyOutput struct {
	Item EncryptedHierarchicalKey
}

func (input GetEncryptedBeaconKeyOutput) Validate() error {
	if input.Item.Validate() != nil {
		return input.Item.Validate()
	}

	return nil
}

type GetEncryptedBranchKeyVersionInput struct {
	Identifier string

	Version string
}

func (input GetEncryptedBranchKeyVersionInput) Validate() error {

	return nil
}

type GetEncryptedBranchKeyVersionOutput struct {
	Item EncryptedHierarchicalKey
}

func (input GetEncryptedBranchKeyVersionOutput) Validate() error {
	if input.Item.Validate() != nil {
		return input.Item.Validate()
	}

	return nil
}

type GetKeyStorageInfoInput struct {
}

func (input GetKeyStorageInfoInput) Validate() error {

	return nil
}

type GetKeyStorageInfoOutput struct {
	LogicalName string

	Name string
}

func (input GetKeyStorageInfoOutput) Validate() error {
	if !utf8.ValidString(input.LogicalName) {
		return fmt.Errorf("Invalid UTF bytes %s ", input.LogicalName)
	}
	if !utf8.ValidString(input.Name) {
		return fmt.Errorf("Invalid UTF bytes %s ", input.Name)
	}

	return nil
}

type WriteNewEncryptedBranchKeyInput struct {
	Active EncryptedHierarchicalKey

	Beacon EncryptedHierarchicalKey

	Version EncryptedHierarchicalKey
}

func (input WriteNewEncryptedBranchKeyInput) Validate() error {
	if input.Active.Validate() != nil {
		return input.Active.Validate()
	}
	if input.Beacon.Validate() != nil {
		return input.Beacon.Validate()
	}
	if input.Version.Validate() != nil {
		return input.Version.Validate()
	}

	return nil
}

type WriteNewEncryptedBranchKeyOutput struct {
}

func (input WriteNewEncryptedBranchKeyOutput) Validate() error {

	return nil
}

type WriteNewEncryptedBranchKeyVersionInput struct {
	Active EncryptedHierarchicalKey

	OldActive EncryptedHierarchicalKey

	Version EncryptedHierarchicalKey
}

func (input WriteNewEncryptedBranchKeyVersionInput) Validate() error {
	if input.Active.Validate() != nil {
		return input.Active.Validate()
	}
	if input.OldActive.Validate() != nil {
		return input.OldActive.Validate()
	}
	if input.Version.Validate() != nil {
		return input.Version.Validate()
	}

	return nil
}

type WriteNewEncryptedBranchKeyVersionOutput struct {
}

func (input WriteNewEncryptedBranchKeyVersionOutput) Validate() error {

	return nil
}

type KeyStorageInterfaceReference struct {
}

func (input KeyStorageInterfaceReference) Validate() error {

	return nil
}

type KeyStoreConfig struct {
	KmsConfiguration KMSConfiguration

	LogicalKeyStoreName string

	DdbClient *dynamodb.Client

	DdbTableName *string

	GrantTokens []string

	Id *string

	KeyManagement KeyManagement

	KmsClient *kms.Client

	Storage Storage
}

func (input KeyStoreConfig) Validate() error {
	if input.KmsConfiguration == nil {
		return fmt.Errorf("input.KmsConfiguration is required but has a nil value.")
	}
	if input.aws_cryptography_keyStore_KeyStoreConfig_kmsConfiguration_Validate() != nil {
		return input.aws_cryptography_keyStore_KeyStoreConfig_kmsConfiguration_Validate()
	}
	if input.DdbTableName != nil {
		if len(*input.DdbTableName) < 3 {
			return fmt.Errorf("TableName has a minimum length of 3 but has the length of %d.", len(*input.DdbTableName))
		}
		if len(*input.DdbTableName) > 255 {
			return fmt.Errorf("TableName has a maximum length of 255 but has the length of %d.", len(*input.DdbTableName))
		}
	}
	if input.aws_cryptography_keyStore_KeyStoreConfig_keyManagement_Validate() != nil {
		return input.aws_cryptography_keyStore_KeyStoreConfig_keyManagement_Validate()
	}
	if input.aws_cryptography_keyStore_KeyStoreConfig_storage_Validate() != nil {
		return input.aws_cryptography_keyStore_KeyStoreConfig_storage_Validate()
	}

	return nil
}

func (input KeyStoreConfig) aws_cryptography_keyStore_KeyStoreConfig_kmsConfiguration_Validate() error {
	if input.KmsConfiguration == nil {
		return nil
	}
	switch unionType := input.KmsConfiguration.(type) {
	case *KMSConfigurationMemberkmsKeyArn:
		if len(unionType.Value) < 1 {
			return fmt.Errorf("KeyIdType has a minimum length of 1 but has the length of %d.", len(unionType.Value))
		}
		if len(unionType.Value) > 2048 {
			return fmt.Errorf("KeyIdType has a maximum length of 2048 but has the length of %d.", len(unionType.Value))
		}
	case *KMSConfigurationMemberkmsMRKeyArn:
		if len(unionType.Value) < 1 {
			return fmt.Errorf("KeyIdType has a minimum length of 1 but has the length of %d.", len(unionType.Value))
		}
		if len(unionType.Value) > 2048 {
			return fmt.Errorf("KeyIdType has a maximum length of 2048 but has the length of %d.", len(unionType.Value))
		}
	case *KMSConfigurationMemberdiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *KMSConfigurationMembermrDiscovery:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input KeyStoreConfig) aws_cryptography_keyStore_KeyStoreConfig_keyManagement_Validate() error {
	if input.KeyManagement == nil {
		return nil
	}
	switch unionType := input.KeyManagement.(type) {
	case *KeyManagementMemberkms:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}
func (input KeyStoreConfig) aws_cryptography_keyStore_KeyStoreConfig_storage_Validate() error {
	if input.Storage == nil {
		return nil
	}
	switch unionType := input.Storage.(type) {
	case *StorageMemberddb:
		if unionType.Value.Validate() != nil {
			return unionType.Value.Validate()
		}
	case *StorageMembercustom:
	// Default case should not be reached.
	default:
		panic(fmt.Sprintf("Unhandled union type: %T ", unionType))
	}

	return nil
}

// HierarchicalKeyTypeMemberActiveHierarchicalSymmetricBeacon
// HierarchicalKeyTypeMemberActiveHierarchicalSymmetricVersion
// HierarchicalKeyTypeMemberHierarchicalSymmetricVersion
type HierarchicalKeyType interface {
	isHierarchicalKeyType()
}

type HierarchicalKeyTypeMemberActiveHierarchicalSymmetricBeacon struct {
	Value ActiveHierarchicalSymmetricBeacon
}

func (*HierarchicalKeyTypeMemberActiveHierarchicalSymmetricBeacon) isHierarchicalKeyType() {}

type HierarchicalKeyTypeMemberActiveHierarchicalSymmetricVersion struct {
	Value ActiveHierarchicalSymmetric
}

func (*HierarchicalKeyTypeMemberActiveHierarchicalSymmetricVersion) isHierarchicalKeyType() {}

type HierarchicalKeyTypeMemberHierarchicalSymmetricVersion struct {
	Value HierarchicalSymmetric
}

func (*HierarchicalKeyTypeMemberHierarchicalSymmetricVersion) isHierarchicalKeyType() {}

// KeyManagementMemberkms
type KeyManagement interface {
	isKeyManagement()
}

type KeyManagementMemberkms struct {
	Value AwsKms
}

func (*KeyManagementMemberkms) isKeyManagement() {}

// KMSConfigurationMemberdiscovery
// KMSConfigurationMemberkmsKeyArn
// KMSConfigurationMemberkmsMRKeyArn
// KMSConfigurationMembermrDiscovery
type KMSConfiguration interface {
	isKMSConfiguration()
}

type KMSConfigurationMemberdiscovery struct {
	Value Discovery
}

func (*KMSConfigurationMemberdiscovery) isKMSConfiguration() {}

type KMSConfigurationMemberkmsKeyArn struct {
	Value string
}

func (*KMSConfigurationMemberkmsKeyArn) isKMSConfiguration() {}

type KMSConfigurationMemberkmsMRKeyArn struct {
	Value string
}

func (*KMSConfigurationMemberkmsMRKeyArn) isKMSConfiguration() {}

type KMSConfigurationMembermrDiscovery struct {
	Value MRDiscovery
}

func (*KMSConfigurationMembermrDiscovery) isKMSConfiguration() {}

// StorageMembercustom
// StorageMemberddb
type Storage interface {
	isStorage()
}

type StorageMembercustom struct {
	Value IKeyStorageInterface
}

func (*StorageMembercustom) isStorage() {}

type StorageMemberddb struct {
	Value DynamoDBTable
}

func (*StorageMemberddb) isStorage() {}

type KeyStoreBaseException interface {
	// This is a dummy method to allow type assertion since Go empty interfaces
	// aren't useful for type assertion checks. No concrete class is expected to implement
	// this method. This is also not exported.
	interfaceBindingMethod()
}

type IKeyStorageInterface interface {
	WriteNewEncryptedBranchKey(WriteNewEncryptedBranchKeyInput) (*WriteNewEncryptedBranchKeyOutput, error)

	WriteNewEncryptedBranchKeyVersion(WriteNewEncryptedBranchKeyVersionInput) (*WriteNewEncryptedBranchKeyVersionOutput, error)

	GetEncryptedActiveBranchKey(GetEncryptedActiveBranchKeyInput) (*GetEncryptedActiveBranchKeyOutput, error)

	GetEncryptedBranchKeyVersion(GetEncryptedBranchKeyVersionInput) (*GetEncryptedBranchKeyVersionOutput, error)

	GetEncryptedBeaconKey(GetEncryptedBeaconKeyInput) (*GetEncryptedBeaconKeyOutput, error)

	GetKeyStorageInfo(GetKeyStorageInfoInput) (*GetKeyStorageInfoOutput, error)
}
